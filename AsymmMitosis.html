<!DOCTYPE html>
<html>
<head>
	<script>
	class Plot {
		constructor(canvasPlot) {
		  this.enforceCircularSymmetryFlag = true;
		  this.shiftQuarterFlag = false;
		  this.originOffset = 10;
		  this.ctx = canvasPlot.getContext("2d");
		  this.canvasWidth = canvasPlot.width;
		  this.canvasHeight = canvasPlot.height;
		  this.canvasXLimits = [this.originOffset, this.canvasWidth - 1 - this.originOffset];
		  this.canvasYLimits = [this.originOffset, this.canvasHeight - 1 - this.originOffset];
		  this.origin = new Point(this.canvasXLimits[0], this.canvasYLimits[1]);
		  this.minXY = new Point(0, 0);
		  this.maxXY = new Point(	this.canvasXLimits[1] - this.canvasXLimits[0],
									this.canvasYLimits[1] - this.canvasYLimits[0]
									);
		  this.resetXY();
		}
		resetXY() {
		  this.x = [];
		  this.y = [];
		  this.pMin = 0;
		  this.pMax = 0;
		  this.qMin = 0;
		  this.qMax = 0;
		  this.maxLength = 1000;
		}
		draw(p, q) {
		  p = this.trimLength(p);
		  q = this.trimLength(q);
		  var i = this.sortedIndex(p);
		  p = this.sorted(i, p);
		  q = this.sorted(i, q);
		  if (this.enforceCircularSymmetryFlag) {
		    var temp = (q[0] + q[q.length - 1]) / 2;
			q[0] = temp;
			q[q.length - 1] = temp;
		  }
		  if (this.shiftQuarterFlag) {
			p = this.shiftQuarter(p);
		    q = this.shiftQuarter(q);
		  }
		  this.setXY(p, q);
		  this.plotXYL();
		}
		shiftQuarter(x) {
		  var N = x.length;
		  var N4 = Math.round(N / 4);
		  var cntr = 0;
		  var y = [];
		  for (cntr = 0; cntr < N; cntr++) {
		    y[cntr] = x[cntr];
		  }
		  for (cntr = 0; cntr < (N - N4); cntr++) {
		    y[cntr + N4] = x[cntr];
		  }
		  for (cntr = (N - N4); cntr < N; cntr++) {
		    y[cntr - (N - N4)] = x[cntr];
		  }
		  return y;
		}
		sorted(i, p) {
		  var N = p.length;
		  var q = [];
		  var cntr;
		  for (cntr = 0; cntr < N; cntr++) {
		    q[cntr] = p[i[cntr]];
		  }
		  return q;
		}
		sortedIndex(p) {
		  var N = p.length;
		  var i = [];
		  var temp = 0;
		  var cntr1 = 0;
		  var cntr2 = 0;
		  for (cntr1 = 0; cntr1 < N; cntr1++) {
		    i[cntr1] = cntr1;
		  }
		  for (cntr1 = 0; cntr1 < (N - 1); cntr1++) {
		    for (cntr2 = cntr1 + 1; cntr2 < N; cntr2++) {
			  if (p[cntr1] > p[cntr2]) {
			    temp = p[cntr1];
				p[cntr1] = p[cntr2];
				p[cntr2] = temp;
			    temp = i[cntr1];
				i[cntr1] = i[cntr2];
				i[cntr2] = temp;
			  }
		    }
		  }
		  return i;
		}
		plotXYL() {
		  var N = this.x.length;
		  if (N < 2) {
		    return;
		  }
		  this.ctx = new SetColors().initialize(this.ctx);
		  this.ctx.beginPath();
		  this.ctx.moveTo(this.x[0], this.y[0]);
		  for (var cntr = 1; cntr < N; cntr++) {
		    this.ctx.lineTo(this.x[cntr], this.y[cntr]);
		  }
		  this.addLimits();
		  this.ctx.stroke();
		}
		addLimits() {
		  this.ctx.font = "15px Arial";
		  this.ctx.fillStyle = "#88FFFF";
		  this.ctx.fillText("Orientation Histogram", 90, 15);
		  this.ctx.font = "10px Arial";
		  this.ctx.fillStyle = "#FFCC66";
		  this.ctx.fillText(this.limitDP(this.pMin), this.origin.x + this.originOffset, this.origin.y + 1 * this.originOffset);
		  this.ctx.fillText(this.limitDP(this.pMax), this.canvasXLimits[1] - 2 * this.originOffset, this.origin.y + 1 * this.originOffset);
		  this.ctx.fillText(this.limitDP(this.qMin), this.origin.x - this.originOffset, this.origin.y - this.originOffset);
		  this.ctx.fillText(this.limitDP(this.qMax), this.origin.x - this.originOffset, this.canvasYLimits[0] + 1 * this.originOffset);
		}
		limitDP(x) {
		  if (("" + x).includes(".")) {
		    x = "" + Math.round(100 * x) / 100;
			if (x.includes(".")) {
			  x = x.substring(0, Math.min(x.length, x.indexOf(".") + 3));
			}
		  }
		  return "" + x;
		}
		setXY(p, q) {
		  this.resetXY();
		  var length = p.length;
		  this.pMin = this.getMin(p);
		  this.pMax = this.getMax(p);
		  this.qMin = this.getMin(q);
		  this.qMax = this.getMax(q);
		  var temp = 0;
		  for (var cntr = 0; cntr < length; cntr++) {
		    this.x[cntr] = this.origin.x +
							(this.minXY.x + (this.maxXY.x - this.minXY.x) * (p[cntr] - this.pMin) / (this.pMax - this.pMin));
		    this.y[cntr] = this.origin.y - 
							(this.minXY.y + (this.maxXY.y - this.minXY.y) * (q[cntr] - this.qMin) / (this.qMax - this.qMin));
		  }
		}
		getMin(x) {
		  var min = x[0];
		  var length = x.length;
		  for (var cntr = 1; cntr < length; cntr++) {
		    if (min > x[cntr]) {
			  min = x[cntr];
			}
		  }
		  return min;
		}
		getMax(x) {
		  var max = x[0];
		  var length = x.length;
		  for (var cntr = 1; cntr < length; cntr++) {
		    if (max < x[cntr]) {
			  max = x[cntr];
			}
		  }
		  return max;
		}
		trimLength(a) {
		  var aLength = a.length;
		  if (aLength <= this.maxLength) {
		    return a;
		  }
		  var a_ = [];
		  for (var cntr = 0; cntr < this.maxLength; cntr++) {
		    a_[cntr] = a[cntr + aLength - this.maxLength];
		  }
		  a = a_;
		  return a;
		}
	}

	class Point {
	  constructor(x, y) {
		this.x = x;
		this.y = y;
	  }
	  getDistance (a, b) {
		return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
	  }
	  add(a) {
	    return new Point(this.x + a.x, this.y + a.y);
	  }
	  getAngleDeg(q) {
	    return (180 / Math.PI) * Math.atan2(q.y - this.y, q.x - this.x);
	  }
	}

	class EBs {
	  constructor() {
		this.resetArrays();
		this.resetParams();
	  }
	  resetArrays() {
		this.t1 = [];
		this.t2 = [];
		this.duration = [];
		this.direction = [];
		this.nEBs = 0;
	  }
	  resetParams() {
		this.offset = 0;
		this.dutyCyle = 0;
		this.length = 0;
		this.gap = 0;
		this.dt1 = 0;
		this.dt2 = 0;
		this.durationMin = 0;
		this.durationMax = 0;
		this.nValidEBs = 0;
		this.Log = "";
	  }
	  append(t1, t2) {
		if ((t1 >= 0) && (t2 <= 1)) {
			this.t1[this.nValidEBs] = t1;
			this.t2[this.nValidEBs] = t2;
			this.duration[this.nValidEBs] = 1;
			this.direction[this.nValidEBs] = (Math.random() > 0.5)? -1:1;
			this.nValidEBs++;
		}
	  }
	  setParams() {
		this.offset = 0.05;
		this.dutyCyle = 0.60;
		this.length = this.dutyCyle / this.nEBs;
		this.gap = (1 - this.dutyCyle) / this.nEBs;

		this.dt1 = 0.01;
		this.dt2 = this.dt1;
		var modFactor = 0.5;
		this.durationMax = (1 / this.dt2 - 1) * 0.6 * (modFactor + (1 - modFactor) * Math.random());
	  }
	  initialize(nEBs) {
		this.resetArrays();
		this.nEBs = nEBs;
		this.setParams();
		var t1 = 0;
		var t2 = 0;
		var t2_ = 0;
		for (var cntr = 0; cntr < nEBs; cntr++) {
		  t1 = t2_ + this.gap * Math.random();
		  t2 = t1 + this.length * Math.random();
		  this.append(t1, t2);
		  t2_ = t2 + this.offset;
		}
		this.nEBs = this.nValidEBs;
	  }
	  update() {
		for (var n = 0; n < this.nEBs; n++) {
		  this.t1[n] += this.dt1 * this.direction[n];
		  this.t2[n] += this.dt2 * this.direction[n];
		  this.duration[n]++;
		  this.enforceDuration(n);
		  var tMaxHalf = 0.5;
		  var shouldChangeFlag = false ||
							((this.direction[n] > 0) && (this.t2[n] > tMaxHalf)) ||
							((this.direction[n] < 0) && (this.t1[n] < tMaxHalf));
		  if (shouldChangeFlag) {
			this.createEB(n);
		  }
		}
	  }
	  enforceDuration(n) {
		var modFactor = 0.5;
		  if (this.duration[n] >  this.durationMax * (modFactor + (1 - modFactor) * Math.random())) {
			this.createEB(n);
		  }
	  }
	  getMinT1() {
		var minT1 = 2;
		for (var n = 0; n < this.nEBs; n++) {
		  if (this.t2[n] >= this.t1[n]) {
			if (minT1 > this.t1[n]) {
			  minT1 = this.t1[n];
			}
		  }
		}
		return minT1;
	  }
	  getMaxT2() {
		var maxT2 = -1;
		for (var n = 0; n < this.nEBs; n++) {
		  if (this.t2[n] >= this.t1[n]) {
			if (maxT2 < this.t2[n]) {
			  maxT2 = this.t2[n];
			}
		  }
		}
		return maxT2;
	  }
	  createEB(n) {
		this.duration[n] = 1;
		this.direction[n] = ((Math.random() + Asymmetry[2]) > 0.5)? 1:-1;
		var Alpha = 0.8;
		if (this.direction[n] > 0) {
			var minT1 = this.getMinT1();
			this.t1[n] = Alpha * minT1 * Math.random();
			var r = Math.random();
			this.t2[n] = Math.min(this.t1[n] + this.length, r * minT1 + (1 - r) * this.t1[n]);
		} else {
			var maxT2 = this.getMaxT2();
			this.t2[n] = 1 - Alpha * Math.random() * (1 - maxT2);
			var r = Math.random();
			this.t1[n] = Math.max(this.t2[n] - this.length, r * maxT2 + (1 - r) * this.t2[n]);
		}
	  }
	}

	class TrackMT {
	  constructor(P1, P2, thetaDeg, nEBs) {
		this.Points = [];
		this.Points[0] = P1;
		this.Points[1] = this.getH(P1, P2, thetaDeg);
		this.Points[2] = P2;
		this.ebs = new EBs();
		this.ebs.initialize(nEBs);
		this.nEBs = this.ebs.nEBs;
	  }
	  update() {
		this.ebs.update();
	  }
	  render(ctx) {
		var alphaMT = 0.2;
		var alphaEB = 1.0;
		//Log("TrackMT::render -> B");
		ctx = this.renderMT(ctx, alphaMT);
		//Log("TrackMT::render -> C");
		var strokeStyleOriginal = ctx.strokeStyle;
		for (var cntr = 0; cntr < this.nEBs; cntr++) {
		  ctx.strokeStyle = (this.ebs.direction[cntr] > 0)? "#FF3300":"#00BBFF";
		  ctx = this.renderEB(ctx, this.ebs.t1[cntr], this.ebs.t2[cntr], alphaEB);
		}
		ctx.strokeStyle = strokeStyleOriginal;
		//Log("TrackMT::render -> E");
		return ctx;
	  }
	  renderEB(ctx, t1, t2, alpha) {
		var q1 = this.getP(t1);
		var q2 = this.getP(t2);
		var qM = this.getP((t1 + t2) / 2);
		ctx.globalAlpha = alpha;
		ctx.beginPath();
		ctx.moveTo(q1.x, q1.y);
		ctx.quadraticCurveTo(qM.x, qM.y, q2.x, q2.y);
		ctx.stroke();
		return ctx;
	  }
	  renderMT(ctx, alpha) {
		ctx.globalAlpha = alpha;
		ctx.beginPath();
		ctx.moveTo(this.Points[0].x, this.Points[0].y);
		ctx.quadraticCurveTo(this.Points[1].x, this.Points[1].y, this.Points[2].x, this.Points[2].y);
		ctx.stroke();
		return ctx;
	  }
	  getH(P1, P2, thetaDeg) {
		var dH = new Point(0, 0);
		var thetaRad = (Math.PI / 180) * thetaDeg;
		var P2m = (Math.cos(thetaRad) > 0)? P2:this.addPoints(P1 , this.diff(P1, P2));
		var M = this.scalePoint(0.5, this.addPoints(P1, P2m));
		var wP1M = this.vNorm(this.diff(M, P1));
		var wMH = wP1M * Math.tan(thetaRad);
		var MS = new Point(P1.y - P2.y, P2.x - P1.x);
		var MH = this.scalePoint(wMH / this.vNorm(MS), MS);
		return this.addPoints(this.addPoints(M, MH), dH);
	  }
	  getP(t) {
		var c0 = (1 - t) * (1 - t);
		var c1 = 2 * (1 - t) * t;
		var c2 = t * t;
		return new Point(
						c0 * this.Points[0].x + c1 * this.Points[1].x + c2 * this.Points[2].x,
						c0 * this.Points[0].y + c1 * this.Points[1].y + c2 * this.Points[2].y
						);
	  }
	  addPoints(p, q) {
		return new Point(p.x + q.x, p.y + q.y);
	  }
	  scalePoint(k, p) {
		return new Point(k * p.x, k * p.y);
	  }
	  vNorm(p) {
		return Math.sqrt(p.x * p.x + p.y * p.y);
	  }
	  diff(p, q) {
		return this.addPoints(p, this.scalePoint(-1, q));
	  }
	  unitDiff(p, q) {
		var r = this.diff(p, q);
		return this.scalePoint(1 / this.vNorm(r), r);
	  }
	}

	class Spindle {
		constructor(P1, P2, minAngleD, maxAngleD, nAngles, nEBs) {
			this.nMTs = nAngles;
			this.arcArray = [];
			this.initializeDirectionData(minAngleD, maxAngleD, nAngles);
			for (var cntr = 0; cntr < this.nMTs; cntr++) {
			  this.arcArray[cntr] = new TrackMT(P1, P2, this.orientations[cntr], nEBs);
			  this.updateDirectionData(cntr);
			}
		}
		update() {
			for (var cntr = 0; cntr < this.nMTs; cntr++) {
			  this.arcArray[cntr].update();
			  this.updateDirectionData(cntr);
			}
		}
		initializeDirectionData(minAngleD, maxAngleD, nAngles) {
			this.angleStep = (maxAngleD - minAngleD) / (nAngles - 1);
			this.nAllOrientations = Math.ceil(360 / this.angleStep);
			this.angleOffset = Math.floor(this.nAllOrientations / 2);
			this.orientations = [];
			this.nOrientations = [];
			for (var cntr = 0; cntr < this.nAllOrientations; cntr++) {
			  this.nOrientations[cntr] = 0;
			  this.orientations[cntr] = minAngleD + cntr * this.angleStep;
			}
		}
		updateDirectionData(trackIndex) {
		  var nEBs = this.arcArray[trackIndex].nEBs;
		  for (var cntrEB = 0; cntrEB < nEBs; cntrEB++) {
		    if (this.arcArray[trackIndex].ebs.duration[cntrEB] == 1) {
			  if (this.arcArray[trackIndex].ebs.direction[cntrEB] > 0) {
				this.nOrientations[trackIndex]++;
			  } else {
				this.nOrientations[trackIndex + this.angleOffset]++;
			  }
			}
		  }
		}
		render(ctx) {
			for (var cntr = 0; cntr < this.nMTs; cntr++) {
			  ctx = this.arcArray[cntr].render(ctx);
			}
			return ctx;
		}
		getComplementaryAngle(x) {
		  return -x + ((x > 0)? 180:-180);
		}
	}

	class SetColors {
	  constructor() {
	  }
	  
	  initialize(ctx) {
		ctx.fillStyle = "#000000";
		ctx.fillRect(0, 0, 300, 150);
		ctx.fillStyle = "#FFFFFF";
		ctx.strokeStyle="#FFFFFF";
		return ctx;
	  }
	}

	class Animate {
		constructor() {
		  if (animateObjectCntr++ > 0) {
			clearInterval(timerID);
		  } else {
		  }
		  animateObjectCntrDuration = 1;

		  plot.resetXY();
		  plot.ctx = new SetColors().initialize(plot.ctx);

		  ctx = new SetColors().initialize(ctx);
		  var minAngleD = -40;
		  var maxAngleD = 40;
		  this.spindle = new Spindle(new Point(X1, Y1), new Point(X2, Y2), minAngleD, maxAngleD, N, nEBs);
		  showValues();
		  ctx = this.spindle.render(ctx);
		  this.timerID = setInterval(drawAll, 1000 / fps);
		}
	}
	</script>



	<script>
	function drawAll() {
	  ctx = new SetColors().initialize(ctx);
	  animate.spindle.update();
	  ctx = animate.spindle.render(ctx);
	  plot.draw(animate.spindle.orientations, animate.spindle.nOrientations);
	  timerID = animate.timerID;
	}
	</script>



	<script>
	function incN() {
	  ++N;
	  animate = new Animate();
	}
	function decN() {
	  if (N > 2) {
	    --N;
	    animate = new Animate();
	  }
	}
	function incSize() {
	  X1 -= 5;
	  X2 += 5;
	  Size = X2 - X1 + 1;
	  animate = new Animate();
	}
	function decSize() {
	  X1 += 5;
	  X2 -= 5;
	  if (X1 > X2) {
	    X1 += 5;
		X2 -= 5;
		return;
	  }
	  Size = X2 - X1 + 1;
	  animate = new Animate();
	}
	function incX1() {
	  X1 += 10;
	  animate = new Animate();
	}
	function decX1() {
	  X1 -= 10;
	  animate = new Animate();
	}
	function incY1() {
	  Y1 += 10;
	  animate = new Animate();
	}
	function decY1() {
	  Y1 -= 10;
	  animate = new Animate();
	}
	function incX2() {
	  X2 += 10;
	  animate = new Animate();
	}
	function decX2() {
	  X2 -= 10;
	  animate = new Animate();
	}
	function incY2() {
	  Y2 += 10;
	  animate = new Animate();
	}
	function decY2() {
	  Y2 -= 10;
	  animate = new Animate();
	}
	function incNEBs() {
	  ++nEBs;
	  animate = new Animate();
	}
	function decNEBs() {
	  --nEBs;
	  animate = new Animate();
	}
	function incFPS() {
	  ++fps;
	  animate = new Animate();
	}
	function decFPS() {
	  --fps;
	  animate = new Animate();
	}
	function incFractionEBs() {
	  Asymmetry[2] = Math.min(0.5, Asymmetry[2] + 0.02);
	  animate = new Animate();
	}
	function decFractionEBs() {
	  Asymmetry[2] = Math.max(-0.5, Asymmetry[2] - 0.02);
	  animate = new Animate();
	}
	</script>

	
	
	<script>
	function showValues() {
	  d$V("nMT", N);
	  d$V("FractionEBs", limitDP(Asymmetry[2]));
	  var x = Math.random();
	}
	function d$V(x, v) {
	  d$(x).innerHTML = v;
	}
	function d$(x) {
	  return document.getElementById(x);
	}
	function Log(x) {
	  d$V("Log", x + "<br />" + d$("Log").innerHTML);
	}
	function limitDP(x) {
	  if (("" + x).includes(".")) {
		x = "" + Math.round(100 * x) / 100;
		if (x.includes(".")) {
		  x = x.substring(0, Math.min(x.length, x.indexOf(".") + 3));
		}
	  }
	  return "" + x;
	}
	
	</script>
</head>




<body>
	<div style="text-align:center;width:300px;">
	  <p><font size="4" color="red">Density</font></p>

	  <button onmouseup="incN()" ontouchstart="incN()">+</button>
	  <a id="nMT"></a>
	  <button onmouseup="decN()" ontouchstart="decN()">-</button><br><br>
	</div>

	<canvas id="myCanvas" width="300" height="150" style="border:1px solid #d3d3d3;">
		Your browser does not support the HTML5 canvas tag.
	</canvas>


	<div style="text-align:center;width:300px;">
	  <p><font size="4" color="red">Asymmetry</font></p>
	  <button onmouseup="incFractionEBs()" ontouchstart="incFractionEBs()">+</button>
	  <a id="FractionEBs"></a>
	  <button onmouseup="decFractionEBs()" ontouchstart="decFractionEBs()">-</button><br><br>
	  <br /><br />
	</div>
	
	<canvas id="plotCanvas" width="300" height="150" style="border:1px solid #d3d3d3;">
		Your browser does not support the HTML5 canvas tag.
	</canvas>

	<div style="text-align:center;width:300px;">
		<a id="Log"></a>
	</div>

	<script>
		var c = d$("myCanvas");
		var ctx = c.getContext("2d");
		ctx.lineWidth = 2;
		
		var cPlot = d$("plotCanvas");
		var plot = new Plot(cPlot);
		var xPlot = [];
		var yPlot = [];
		

		var N = 5;
		var X1 = 0;
		var Y1 = 74;
		var X2 = 299;
		var Y2 = 74;
		var Size = X2 - X1 + 1;
		var nEBs = 10;
		var fps = 8;
		var Asymmetry = [0, 0, 0.20, 0, 0];

		var animateObjectCntr = 0;
		var animateObjectCntrDuration = 0;
		var animate = new Animate();
		var timerID = animate.timerID;
		var fullQuality = c.toDataURL("image/gif", 1.0);
	</script> 
</body>
</html>
